#---- ReForgeEngine/Core/ProjectManager.cs
using System.Text.Json;
using ReForge.Engine.Core;
using ReForge.Engine.World;

namespace ReForge.Engin.Core;

public static class ProjectManager
{
    static string _configPath = Path.Combine(AppContext.BaseDirectory, "lastProjectPath.txt");
    public static ProjectSettings? CurrentProject { get; private set; }
    public static string CurrentSceneName { get; set; }
    public static Scene? CurrentScene { get; set; }
    public static string ProjectRootPath { get; private set; }
    public static bool IsSaved { get; set; } = false;

    public static bool LoadProject(string filePath)
    {
        if (!File.Exists(filePath)) return false;

        try
        {
            string json = File.ReadAllText(filePath);
            CurrentProject = JsonSerializer.Deserialize<ProjectSettings>(json);

            if (CurrentProject != null)
            {
                ProjectRootPath = Path.GetDirectoryName(filePath) ?? "";
                IsSaved = true;
                return true;
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Erreur lors du chargement du projet : {e.Message}");
        }
        return false;
    }
    
    public static void SaveLastProjectPath()
    {
        string path = Path.Combine(ProjectRootPath, CurrentProject.ProjectName + ".reforge");
        File.WriteAllText(_configPath, path);
    }

    public static bool TryLoadLastProject()
    {
        if (File.Exists(_configPath))
        {
            string path = File.ReadAllText(_configPath);
            return LoadProject(path);
        }
        return false;
    }

    public static void CreateEmptyTemporaryProject()
    {
        CurrentProject = new ProjectSettings
        {
            ProjectName = "Nouveau Projet",
            AssetDirectory = "Assets",
            StartScenePath = "Scenes/StartScene.scn"
        };
        
        ProjectRootPath = AppContext.BaseDirectory;
        
        Directory.CreateDirectory(Path.Combine(ProjectRootPath, CurrentProject.AssetDirectory));
        
        string assetsBase = Path.Combine(AppContext.BaseDirectory, CurrentProject.AssetDirectory);
        
        foreach (AssetType type in Enum.GetValues(typeof(AssetType)))
        {
            string dirPath;
            if (type == AssetType.Scenes)
            {
                dirPath = Path.Combine(assetsBase, type.ToString());
            }
            else
            {
                dirPath = Path.Combine(assetsBase, type.ToString());
            }
            Directory.CreateDirectory(dirPath);
        }
    }

    public static void SaveProject()
    {
        if (CurrentProject == null) return;

        try
        {
            string targetPath = ProjectRootPath;
            if (ProjectRootPath == AppContext.BaseDirectory)
            {
                targetPath = Path.Combine(AppContext.BaseDirectory, "Projects", CurrentProject.ProjectName);
            }
            
            Directory.CreateDirectory(targetPath);
            ProjectRootPath = targetPath;
            
            foreach (AssetType type in Enum.GetValues(typeof(AssetType)))
            {
                string dirPath;
                if (type == AssetType.Scenes)
                {
                    dirPath = Path.Combine(ProjectRootPath, CurrentProject.SceneDirectory);
                }
                else
                {
                    dirPath = Path.Combine(ProjectRootPath, CurrentProject.AssetDirectory, type.ToString());
                }
                Directory.CreateDirectory(dirPath);
            }
            
            string fullpath = Path.Combine(ProjectRootPath, $"{CurrentProject.ProjectName}.reforge");
            var options = new JsonSerializerOptions { WriteIndented = true };
            string json = JsonSerializer.Serialize(CurrentProject, options);

            File.WriteAllText(fullpath,json);
            
            SaveLastProjectPath();
            
            IsSaved = true;
            Console.WriteLine($"Projet sauvegardé : {fullpath}");
        }
        catch (Exception e)
        {
            Console.WriteLine($"Erreur lors de la sauvegarde du projet : {e.Message}");
        }
    }

    public static void SaveScene()
    {
        if (CurrentProject == null || string.IsNullOrEmpty(CurrentSceneName)) return;
        
        string scenePath = Path.Combine(ProjectRootPath, CurrentProject.SceneDirectory);
        string sceneRelativePath = Path.Combine(CurrentProject.SceneDirectory, $"{CurrentSceneName}.scn");
        Directory.CreateDirectory(scenePath);
        string fullPath = Path.Combine(scenePath, $"{CurrentSceneName}.scn");
        
        CurrentProject.LastScenePath = sceneRelativePath;
        
        SceneSerializer.Save(CurrentScene, fullPath);
        
        SaveProject();
    }
}



#---- ReForgeEngine/Core/Attributes.cs
namespace ReForge.Engine.Core;

using System;

[AttributeUsage(AttributeTargets.Class)]
public class HiddenBehaviorAttribute : Attribute 
{
}

[AttributeUsage(AttributeTargets.Class)]
public class HiddenSelectableBehaviorAttribute : Attribute
{
}



#---- ReForgeEngine/Core/AssetManager.cs
using Raylib_cs;

namespace ReForge.Engine.Core;

public class AssetManager
{
    Dictionary<string, Texture2D> _textures = new();
    
    public Texture2D GetTexture(string path)
    {
        if (!_textures.ContainsKey(path))
        {
            _textures[path] = Raylib.LoadTexture(path);
        }
        return _textures[path];
    }

    public void UnloadAll()
    {
        foreach (var texture in _textures.Values)
        {
            Raylib.UnloadTexture(texture);
        }
        _textures.Clear();
    }
}



#---- ReForgeEngine/Core/SceneSerializer.cs
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using ReForge.Engin.Core;
using ReForge.Engine.World;
using ReForge.Engine.World.Components;

namespace ReForge.Engine.Core;

public static class SceneSerializer
{
    static JsonSerializerOptions _options = new JsonSerializerOptions
    {
        WriteIndented = true,
        IncludeFields = true,
        UnknownTypeHandling = (JsonUnknownTypeHandling)JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor,
        
        TypeInfoResolver = new DefaultJsonTypeInfoResolver
        {
            Modifiers = { CreateBehaviorResolver, CreateEntityResolver }
        }
    };

    static void CreateEntityResolver(JsonTypeInfo typeInfo)
    {
        if (typeInfo.Type == typeof(Entity))
        {
            var polymorphismOptions = new JsonPolymorphismOptions();
        
            polymorphismOptions.DerivedTypes.Add(new JsonDerivedType(typeof(Tilemap), "Tilemap"));
            
            typeInfo.PolymorphismOptions = polymorphismOptions;
        }
    }

    static void CreateBehaviorResolver(JsonTypeInfo typeInfo)
    {
        if (typeInfo.Type == typeof(Behavior))
        {
            var behaviorTypes = Assembly.GetAssembly(typeof(Behavior))!
                .GetTypes()
                .Where(t => t.IsSubclassOf(typeof(Behavior)) && !t.IsAbstract);
            
            var polymorphismOptions = new JsonPolymorphismOptions();

            foreach (var type in behaviorTypes)
            {
                polymorphismOptions.DerivedTypes.Add(new JsonDerivedType(type, type.Name));
            }

            typeInfo.PolymorphismOptions = polymorphismOptions;
        }
    }

    public static void Save(Scene scene, string filePath)
    {
        try
        {
            string? directory = Path.GetDirectoryName(filePath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }
            
            string json = JsonSerializer.Serialize(scene.Entities, _options);
            File.WriteAllText(filePath, json);
            Console.WriteLine("Scène sauvegardée avec succès !");
        } catch (Exception e)
        {
            Console.WriteLine($"Erreur lors de la sauvegarde du fichier {filePath}: {e.Message}");
        }
    }
    
    public static void Load(Scene scene, Engine engine, string filePath)
    {
        if (!File.Exists(filePath)) return;

        try
        {
            string json = File.ReadAllText(filePath);
            var loadedEntities = JsonSerializer.Deserialize<List<Entity>>(json, _options);

            if (loadedEntities != null)
            {
                scene.Entities.Clear();

                foreach (var entity in loadedEntities)
                {
                    // Réhydratation de la texture via chemin relatif
                    if (entity.Sprite != null && !string.IsNullOrEmpty(entity.Sprite.TexturePath))
                    {
                        // On combine avec le root du projet pour trouver le fichier
                        string fullPath = Path.Combine(ProjectManager.ProjectRootPath, ProjectManager.CurrentProject.AssetDirectory, entity.Sprite.TexturePath);
                        entity.Sprite.Texture = engine.AssetManager.GetTexture(fullPath);
                        
                        // Synchronisation spécifique Tilemap: la texture interne de rendu doit être renseignée
                        if (entity is Tilemap tilemap)
                        {
                            tilemap.Texture = entity.Sprite.Texture;
                            if (tilemap.TileSize <= 0) 
                            {
                                tilemap.TileSize = ProjectManager.CurrentProject.TileSize;
                            }
                        }
                    }

                    if (entity.Behaviors != null)
                    {
                        var behaviorsToRestore = entity.Behaviors.ToList();
                    
                        entity.Behaviors.Clear(); 

                        foreach (var behavior in behaviorsToRestore)
                        {
                            entity.AddBehavior(behavior); 
                        }
                    }

                    scene.AddEntity(entity);
                }
                Console.WriteLine("Scène chargée et Behaviors réhydratés !");
            }
        }
        catch (Exception e)
        {
            Console.WriteLine($"Erreur : {e.Message}");
        }
    }
}



#---- ReForgeEngine/Core/Engine.cs
using Raylib_cs;
using ReForge.Engine.World;

namespace ReForge.Engine.Core;

public class Engine
{
    int _width;

    int _height;

    string _winName;
    
    public static Engine Instance { get; private set; } = null!;

    public Engine(int width, int height, string winName)
    {
        _width = width;
        _height = height;
        _winName = winName;

        Instance = this;
    }
    
    public void Initialize()
    {
        Raylib.SetConfigFlags(ConfigFlags.ResizableWindow);
        Raylib.InitWindow(_width, _height, _winName);
        Raylib.SetTargetFPS(60);
    }

    public void Run()
    {
        while (!Raylib.WindowShouldClose())
        {
            float deltaTime = Raylib.GetFrameTime();
        
            Update(deltaTime);
        
            Raylib.BeginDrawing();
            Render();
            Raylib.EndDrawing();
        }
    }

    public void Update(float deltaTime)
    {
        CurrentScene.Update(deltaTime);
    }

    public void Render()
    {
        Raylib.ClearBackground(Color.Black);
        
        var camEntity = CurrentScene.GetActiveCameraEntity();
        
        if (camEntity != null && !ExternalCameraActive)
        {
            Camera2D worldCamera = new Camera2D
            {
                Target = camEntity.Position,
                Offset = new System.Numerics.Vector2(_width / 2, _height / 2),
                Zoom = 1.0f,
                Rotation = 0.0f,
            };
            
            Raylib.BeginMode2D(worldCamera);
            CurrentScene.Draw();
            Raylib.EndMode2D();
        }
        else
        {
            CurrentScene.Draw();
        }
        
    }

    public void CleanUp()
    {
        Raylib.CloseWindow();
        AssetManager.UnloadAll();
    }
    
    public AssetManager AssetManager { get; set; } = new AssetManager();
    
    public Texture2D LoadTexture(string path) => AssetManager.GetTexture(path);
    
    public Scene CurrentScene { get; set; } = new Scene();
    
    // When true, an external system (e.g., the Editor) manages the world camera.
    public bool ExternalCameraActive { get; set; } = false;
    
    public void DestroyEntity(Entity entity) => CurrentScene.DestroyEntity(entity);
}



#---- ReForgeEngine/Core/ProjectSettings.cs
namespace ReForge.Engine.Core;

public enum AssetType
{
    Actors,
    Decors,
    Scenes,
    VFX,
    SFX,
    Images
}

public class ProjectSettings
{
    public string ProjectName { get; set; } = "Untitled";
    public string AssetDirectory { get; set; } = "Assets";
    public string SceneDirectory { get; set; } = "Scenes";
    public string LastScenePath { get; set; }
    public string StartScenePath { get; set; }
    public int TileSize { get; set; } = 32;

    public string GetFullPath(string relativePath)
    {
        return Path.Combine(AssetDirectory, relativePath);
    }
}



#---- ReForgeEngine/World/Scene.cs
using Raylib_cs;
using ReForge.Engine.Physics;
using ReForge.Engine.World.Behaviors;

namespace ReForge.Engine.World;

public class Scene
{
    List<Entity> _entities = new List<Entity>();
    List<Entity> _entitiesToRemove = new List<Entity>();
    
    public void AddEntity(Entity entity)
    {
        _entities.Add(entity);
    }
    
    public void Update(float deltaTime)
    {
        foreach (Entity entity in _entities)
        {
            entity.Update(deltaTime);
        }

        CollisionSystem.Update(_entities);
        CleanUp();
    }
    
    public void Draw()
    {
        CleanUp();
        foreach (Entity entity in _entities.OrderBy(e => e.ZIndex))
        {
            entity.Draw();
        }
    }
    
    public void DestroyEntity(Entity entity)
    {
        _entitiesToRemove.Add(entity);
    }
    
    void CleanUp()
    {
        if (_entitiesToRemove.Count == 0) return;
        
        foreach (Entity entity in _entitiesToRemove)
        {
            _entities.Remove(entity);
        }
        _entitiesToRemove.Clear();
    }

    public Entity? GetActiveCameraEntity()
    {
        return _entities.FirstOrDefault(e => e.GetBehavior<CameraFollow>() != null);
    }
    
    public List<Entity> Entities => _entities;
}



#---- ReForgeEngine/World/ActionCommand.cs
using System.Numerics;

namespace ReForge.Engine.World;

public enum ActionVerb
{
    Destroy,
    Teleport,
    ToggleActive,
    ChangeIndex
}

public class ActionCommand
{
    public ActionVerb Verb { get; set; }
    public string TargetTag { get; set; } = "";
    public bool TargetSelf { get; set; } = false;
    public Vector2 Destination { get; set; }
}



#---- ReForgeEngine/World/Tilemap.cs
using System.Numerics;
using Raylib_cs;

namespace ReForge.Engine.World;

public class TileLayer
{
    public int[][] Data { get; set; }
    public bool IsCollidable { get; set;}
    public bool IsForeground { get; set;}
    public TileLayer() { }
    
    public TileLayer(int width, int height)
    {
        Data = new int[height][];
        for (int i = 0; i < height; i++)
        {
            Data[i] = new int[width];
        }
    }
    
    public void Resize(int newWidth, int newHeight)
    {
        int[][] newData = new int[newHeight][];
        for (int i = 0; i < newHeight; i++)
        {
            newData[i] = new int[newWidth];
            if (i < Data.Length)
            {
                Array.Copy(
                    Data[i], 
                    newData[i], 
                    Math.Min(Data[i].Length, newWidth)
                );
            }
        }
        Data = newData;
    }
}

public class Tilemap: Entity
{
    public List<TileLayer> Layers { get; set; } = new List<TileLayer>();
    public int TileSize { get; set; }
    
    [System.Text.Json.Serialization.JsonIgnore] 
    public new Texture2D Texture { get; set; }
    
    public Tilemap(): base() { }
    
    public Tilemap(Vector2 position, int tileSize, Texture2D texture, string texturePath) : base(position, texture, "Tilemap", texturePath)
    {
        TileSize = tileSize;
        this.Texture = texture;
    }
    
    public override Entity Clone()
    {
        var clone = new Tilemap(this.Position, this.TileSize, this.Texture, this.TexturePath)
        {
            Name = this.Name,
            ZIndex = this.ZIndex
        };
        
        // Copie profonde des layers
        foreach (var layer in this.Layers)
        {
            var newLayer = new TileLayer();
            newLayer.IsCollidable = layer.IsCollidable;
            newLayer.IsForeground = layer.IsForeground;
            if (layer.Data != null)
            {
                int h = layer.Data.Length;
                int[][] newData = new int[h][];
                for (int i = 0; i < h; i++)
                {
                    int w = layer.Data[i].Length;
                    newData[i] = new int[w];
                    Array.Copy(layer.Data[i], newData[i], w);
                }
                newLayer.Data = newData;
            }
            clone.Layers.Add(newLayer);
        }
        
        // Tags
        foreach (var tag in this.Tags)
        {
            clone.AddTag(tag);
        }
        
        // Comportements
        foreach (var behavior in this.Behaviors)
        {
            var b = behavior.Clone();
            clone.AddBehavior(b);
        }
        
        return clone;
    }
    
    public List<TileLayer> GetLayers() => Layers;
    public void AddLayer(TileLayer layer) => Layers.Add(layer);
    
    public override void Draw()
    {
        // Si aucune tuile à dessiner (toutes les layers vides), on dessine le sprite de base
        bool hasAnyTile = false;
        foreach (var layer in Layers)
        {
            int h = layer.Data.Length;
            if (h == 0) continue;
            int w = layer.Data[0].Length;
            for (int y = 0; y < h; y++)
            {
                for (int x = 0; x < w; x++)
                {
                    if (layer.Data[y][x] != 0)
                    {
                        hasAnyTile = true;
                        break;
                    }
                }
                if (hasAnyTile) break;
            }
            if (hasAnyTile) break;
        }

        if (!hasAnyTile)
        {
            base.Draw();
            return;
        }

        foreach (TileLayer layer in Layers)
        {
            DrawLayer(layer);
        }
    }

    public void DrawLayer(TileLayer layer)
    {
        int gridHeight = layer.Data.Length;
        int gridWidth = layer.Data[0].Length;
        
        for (int y = 0; y < gridHeight; y++)
        {
            for (int x = 0; x < gridWidth; x++)
            {   
                int tileId = layer.Data[y][x];

                if (tileId == 0) continue;

                Vector2 screenPos = new Vector2(
                    Position.X + (x * TileSize), 
                    Position.Y + (y * TileSize)
                );

                DrawTile(tileId, screenPos);
            }
        }
    }
    
    void DrawTile(int tileId, Vector2 screenPos)
    {
        if(Texture.Id == 0 || TileSize <= 0) return;
        
        int tilesPerRow = Texture.Width / TileSize;
        
        if(tilesPerRow <= 0) return;

        // Les IDs stockés dans la layer sont 1-based (0 = vide)
        int atlasIndex = tileId - 1;
        int column = atlasIndex % tilesPerRow;
        int row = atlasIndex / tilesPerRow;

        Rectangle sourceRec = new Rectangle(
            column * TileSize, 
            row * TileSize, 
            TileSize, 
            TileSize
        );

        Raylib.DrawTextureRec(Texture, sourceRec, screenPos, Color.White);
    }
}



#---- ReForgeEngine/World/Behavior.cs
using System.Text.Json.Serialization;

namespace ReForge.Engine.World;

public abstract class Behavior
{
    [JsonIgnore]
    public Entity Owner { get; set; } = null!;
    
    // Ordre d'exécution des behaviors pendant Update (plus grand = plus tard)
    public int UpdateOrder { get; set; } = 0;
    
    public virtual void Initialize() {}
    public abstract void Update(float deltaTime);
    public abstract Behavior Clone();
    public virtual void OnReceivedEvent(string eventName, object? data = null) {}
}



#---- ReForgeEngine/World/Components/SpriteComponent.cs
using System.Text.Json.Serialization;
using Raylib_cs;
using ReForge.Engine.Core;

namespace ReForge.Engine.World.Components;

[HiddenBehavior]
public class SpriteComponent: Behavior
{
    public string TexturePath { get; set; } = "";
    
    [JsonIgnore]
    public Texture2D Texture { get; set; }

    public override void Update(float deltaTime)
    {
        //
    }

    public override Behavior Clone()
    {
        return new SpriteComponent()
        {
            TexturePath = this.TexturePath,
            Texture = this.Texture
        };
    }
}



#---- ReForgeEngine/World/Components/TransformComponent.cs
using System.Numerics;
using ReForge.Engine.Core;

namespace ReForge.Engine.World.Components;

[HiddenBehavior]
public class TransformComponent: Behavior
{
    public Vector2 Position { get; set; }
    
    public override void Update(float deltaTime)
    {
        //
    }

    public override Behavior Clone()
    {
        return new TransformComponent()
        {
            Position = this.Position
        };
    }
}



#---- ReForgeEngine/World/Behaviors/Timer.cs
namespace ReForge.Engine.World.Behaviors;

public class Timer: Behavior
{
    public float Duration { get; set; }
    float _elapsedTime;


    public override void Update(float deltaTime)
    {
        _elapsedTime += deltaTime;

        if (_elapsedTime >= Duration)
        {
            Core.Engine.Instance.CurrentScene.DestroyEntity(Owner);
        }
    }

    public override Behavior Clone()
    {
        return new Timer { Duration = this.Duration };
    }
}



#---- ReForgeEngine/World/Behaviors/Oscillator.cs
using System.Numerics;

namespace ReForge.Engine.World.Behaviors;

public class Oscillator: Behavior
{
    public Vector2 Direction { get; set; } = new Vector2(1, 0);
    public float Distance { get; set; } = 100f;
    public float Speed { get; set; } = 2f;
    
    float _timer = 0f;
    Vector2 _startPosition;
    bool _initialized = false;
    
    
    public override void Update(float deltaTime)
    {
        if (!_initialized)
        {
            _startPosition = Owner.Position;
            _initialized = true;
        }
        
        _timer += deltaTime;
        
        float offset = (float)Math.Sin(_timer) * Distance;
        
        Owner.Position = _startPosition + (Direction * offset);
    }

    public override Behavior Clone()
    {
        return new Oscillator 
        { 
            Direction = this.Direction, 
            Distance = this.Distance, 
            Speed = this.Speed 
        };
    }
}



#---- ReForgeEngine/World/Behaviors/BoxCollider.cs
using Raylib_cs;
using ReForge.Engine.World.Components;

namespace ReForge.Engine.World.Behaviors;

public class BoxCollider: Behavior
{
    public float Width { get; set; }
    public float Height { get; set; }

    public bool IsTrigger { get; set; } = false;
    
    public Action<Entity>? OnCollisionEnter;
    public Action<Entity>? OnCollisionStay;
    public Action<Entity>? OnCollisionExit;
    
    public Rectangle Bounds => new Rectangle(Owner.Position.X, Owner.Position.Y, Width, Height);

    public override void Initialize()
    {
        /*OnCollisionEnter += (target) => Owner.BroadcastEvent("OnCollisionEnter", target);
        OnCollisionExit += (target) => Owner.BroadcastEvent("OnCollisionExit", target);*/
        OnCollisionEnter = (target) => Owner.BroadcastEvent("OnCollisionEnter", target);
        OnCollisionExit = (target) => Owner.BroadcastEvent("OnCollisionExit", target);
    }
    
    public override void Update(float deltaTime)
    {
        if (Width == 0 || Height == 0)
        {
            var sprite = Owner.GetBehavior<SpriteComponent>();
            if(sprite != null && sprite.Texture.Id != 0)
            {
                Width = sprite.Texture.Width;
                Height = sprite.Texture.Height;
            }
        }
    }

    public override Behavior Clone()
    {
        return new BoxCollider 
        { 
            Width = this.Width, 
            Height = this.Height, 
            IsTrigger = this.IsTrigger 
        };
    }

    public void DrawDebug()
    {
        Raylib.DrawRectangleLinesEx(Bounds, 2, Color.Green);
    }
}



#---- ReForgeEngine/World/Behaviors/Follow.cs
using System.Numerics;
using ReForge.Engine.World;

namespace ReForge.Engine.World.Behaviors;

public class Follow: Behavior
{
    public Entity Target { get; set; }
    public float Smoothness { get; set; } = 5.0f;
    
    public override void Update(float deltaTime)
    {
        if (Target == null)
        {
            Console.WriteLine("No target found");
            Target = Core.Engine.Instance.CurrentScene.Entities
                .FirstOrDefault(e => e.Tags.Any(t => t.Trim().Equals("Player", StringComparison.InvariantCultureIgnoreCase)));
        }
        
        if(Target == null) return;
        
        Owner.Position = Vector2.Lerp(Owner.Position, Target.Position, Smoothness * deltaTime);
    }

    public override Behavior Clone()
    {
        return new Follow
        {
            Target = this.Target,
            Smoothness = this.Smoothness
        };
    }
}



#---- ReForgeEngine/World/Behaviors/WorldBounds.cs
using System.Numerics;
using ReForge.Engine.World.Components;

namespace ReForge.Engine.World.Behaviors;

public class WorldBounds: Behavior
{
    public Vector2 MinBounds { get; set; } = new Vector2(float.MinValue, float.MinValue);
    public Vector2 MaxBounds { get; set; } = new Vector2(float.MaxValue, float.MaxValue);

    public WorldBounds()
    {
        // S'assurer que le clamp s'applique après les déplacements
        UpdateOrder = 1000;
    }
    
    public override void Update(float deltaTime)
    {
        // Si les limites sont aux valeurs par défaut (infinies), on ne bloque rien
        if (MinBounds.X <= float.MinValue + 1 && MaxBounds.X >= float.MaxValue - 1)
        {
            return;
        }

        Vector2 position = Owner.Position;
        Vector2 maxEffective = MaxBounds;
        
        var sprite = Owner.GetBehavior<SpriteComponent>();
        if (sprite != null && sprite.Texture.Id != 0)
        {
            // On réduit la zone de mouvement autorisée de la taille du sprite
            maxEffective.X -= sprite.Texture.Width;
            maxEffective.Y -= sprite.Texture.Height;
        }
        
        position.X = Math.Clamp(position.X, MinBounds.X, maxEffective.X);
        position.Y = Math.Clamp(position.Y, MinBounds.Y, maxEffective.Y);
        
        Owner.Position = position;
    }

    public override Behavior Clone()
    {
        return new WorldBounds
        {
            MinBounds = this.MinBounds,
            MaxBounds = this.MaxBounds,
            UpdateOrder = this.UpdateOrder
        };
    }
}



#---- ReForgeEngine/World/Behaviors/Velocity.cs
using System.Numerics;

namespace ReForge.Engine.World.Behaviors;

public class Velocity : Behavior
{
    public Vector2 Current { get; set; } = Vector2.Zero;
    public float Friction { get; set; } = 0.95f;
    public override void Update(float deltaTime)
    {
        Owner.Position += Current * deltaTime;
        Current *= Friction;
    }

    public override Behavior Clone()
    {
        return new Velocity
        {
            Current = this.Current,
            Friction = this.Friction
        };
    }
}



#---- ReForgeEngine/World/Behaviors/InputMovable.cs
using System.Numerics;
using Raylib_cs;

namespace ReForge.Engine.World.Behaviors;

public class InputMovable: Behavior
{
    public float Speed { get; set; } = 100f;
    public float Acceleration { get; set; } = 10f;
    
    public override void Update(float deltaTime)
    {
        var velocity = Owner.GetBehavior<Velocity>();
        
        Vector2 direction = Vector2.Zero;
        if (Raylib.IsKeyDown(KeyboardKey.Right)) direction.X += Speed * deltaTime;
        if (Raylib.IsKeyDown(KeyboardKey.Left)) direction.X -= Speed * deltaTime;
        if (Raylib.IsKeyDown(KeyboardKey.Up)) direction.Y -= Speed * deltaTime;
        if (Raylib.IsKeyDown(KeyboardKey.Down)) direction.Y += Speed * deltaTime;

        if (direction != Vector2.Zero)
        {
            if (velocity != null)
            {
                velocity.Current += direction * Acceleration;
            }
            else
            {
                Owner.Position += direction * Speed * deltaTime;
            }
        }
    }

    public override Behavior Clone()
    {
        return new InputMovable { Speed = this.Speed };
    }
}



#---- ReForgeEngine/World/Behaviors/CameraFollow.cs
using System.Numerics;
using Raylib_cs;
using ReForge.Engine.World;

namespace ReForge.Engine.World.Behaviors;

public class CameraFollow: Behavior
{
    public Entity Target { get; set; }
    public float Smoothness { get; set; } = 5.0f;
    
    public Vector2 MinBounds { get; set; } = new Vector2(float.MinValue, float.MinValue);
    public Vector2 MaxBounds { get; set; } = new Vector2(float.MaxValue, float.MaxValue);
    
    public override void Update(float deltaTime)
    {
        if (Target == null)
        {
            Console.WriteLine("No target found");
            Target = Core.Engine.Instance.CurrentScene.Entities
                .FirstOrDefault(e => e.Tags.Any(t => t.Trim().Equals("Player", StringComparison.InvariantCultureIgnoreCase)));
        }
        
        if(Target == null) return;
        
        Vector2 nextPos = Vector2.Lerp(Owner.Position, Target.Position, Smoothness * deltaTime);
        
        float screenWidth = Raylib.GetScreenWidth();
        float screenHeight = Raylib.GetScreenHeight();
        
        float minX = MinBounds.X + (screenWidth / 2);
        float maxX = MaxBounds.X - (screenWidth / 2);
        float minY = MinBounds.Y + (screenHeight / 2);
        float maxY = MaxBounds.Y - (screenHeight / 2);

        if (maxX >= minX)
        {
            nextPos.X = Math.Clamp(nextPos.X, minX, maxX);
        }
        else
        {
            nextPos.X = MinBounds.X + (MaxBounds.X - MinBounds.X) / 2;
        }

        if (maxY >= minY)
        {
            nextPos.Y = Math.Clamp(nextPos.Y, minY, maxY);
        }
        else
        {
            nextPos.Y = MinBounds.Y + (MaxBounds.Y - MinBounds.Y) / 2;
        }
        
        Owner.Position = nextPos;
    }

    public override Behavior Clone()
    {
        return new CameraFollow
        {
            Target = this.Target,
            Smoothness = this.Smoothness
        };
    }
}



#---- ReForgeEngine/World/ChunkedTilemap.cs
using System.Numerics;
using Raylib_cs;

namespace ReForge.Engine.World;

public class ChunkedTilemap : Entity
{
    public sealed class Chunk
    {
        public readonly int[][] Data; // [y][x]
        public Chunk(int size)
        {
            Data = new int[size][];
            for (int y = 0; y < size; y++)
            {
                Data[y] = new int[size];
            }
        }
    }

    public sealed class Layer
    {
        // Dictionnaire clairsemé de chunks pour cette layer
        public readonly Dictionary<(int cx, int cy), Chunk> Chunks = new();
    }

    public int TileSize { get; set; }
    public int ChunkSize { get; set; } = 64; // défaut raisonnable

    [System.Text.Json.Serialization.JsonIgnore]
    public new Texture2D Texture { get; set; }

    public List<Layer> Layers { get; } = new();

    public ChunkedTilemap() : base() { }

    public ChunkedTilemap(Vector2 position, int tileSize, Texture2D texture, string texturePath)
        : base(position, texture, "ChunkedTilemap", texturePath)
    {
        TileSize = tileSize;
        Texture = texture;
        // Par défaut, on crée une layer
        Layers.Add(new Layer());
    }

    public override Entity Clone()
    {
        var clone = new ChunkedTilemap(this.Position, this.TileSize, this.Texture, this.TexturePath)
        {
            Name = this.Name,
            ZIndex = this.ZIndex,
            ChunkSize = this.ChunkSize
        };

        foreach (var tag in this.Tags)
            clone.AddTag(tag);

        foreach (var behavior in this.Behaviors)
            clone.AddBehavior(behavior.Clone());

        // Copie superficielle des données (profonde par chunks)
        clone.Layers.Clear();
        foreach (var layer in Layers)
        {
            var newLayer = new Layer();
            foreach (var kvp in layer.Chunks)
            {
                var src = kvp.Value;
                var dst = new Chunk(ChunkSize);
                for (int y = 0; y < ChunkSize; y++)
                {
                    Array.Copy(src.Data[y], dst.Data[y], ChunkSize);
                }
                newLayer.Chunks[kvp.Key] = dst;
            }
            clone.Layers.Add(newLayer);
        }

        return clone;
    }

    // API principale
    public void EnsureLayer(int layerIndex)
    {
        while (Layers.Count <= layerIndex) Layers.Add(new Layer());
    }

    public void SetTile(int layerIndex, int gridX, int gridY, int tileId)
    {
        EnsureLayer(layerIndex);
        var (cx, cy, lx, ly) = ToChunkCoords(gridX, gridY);
        var chunk = GetOrCreateChunk(Layers[layerIndex], cx, cy);
        chunk.Data[ly][lx] = tileId; // 1-based attendu (0 = vide)
    }

    public int GetTile(int layerIndex, int gridX, int gridY)
    {
        if (layerIndex < 0 || layerIndex >= Layers.Count) return 0;
        var (cx, cy, lx, ly) = ToChunkCoords(gridX, gridY);
        var dict = Layers[layerIndex].Chunks;
        if (!dict.TryGetValue((cx, cy), out var chunk)) return 0;
        return chunk.Data[ly][lx];
    }

    public void ClearTile(int layerIndex, int gridX, int gridY)
    {
        SetTile(layerIndex, gridX, gridY, 0);
    }

    (int cx, int cy, int lx, int ly) ToChunkCoords(int gridX, int gridY)
    {
        int cs = ChunkSize;
        // gestion des négatifs: Division entière en C# tronque vers 0, on veut une division de plancher
        int cx = FloorDiv(gridX, cs);
        int cy = FloorDiv(gridY, cs);
        int lx = Mod(gridX, cs);
        int ly = Mod(gridY, cs);
        return (cx, cy, lx, ly);
    }

    static int FloorDiv(int a, int b)
    {
        int q = a / b;
        int r = a % b;
        if ((r != 0) && ((r > 0) != (b > 0))) q--;
        return q;
    }

    static int Mod(int a, int b)
    {
        int r = a % b;
        if (r < 0) r += Math.Abs(b);
        return r;
    }

    Chunk GetOrCreateChunk(Layer layer, int cx, int cy)
    {
        var key = (cx, cy);
        if (!layer.Chunks.TryGetValue(key, out var chunk))
        {
            chunk = new Chunk(ChunkSize);
            layer.Chunks[key] = chunk;
        }
        return chunk;
    }

    public override void Draw()
    {
        if (Texture.Id == 0 || TileSize <= 0) return;
        int tilesPerRow = Texture.Width / TileSize;
        if (tilesPerRow <= 0) return;

        // MVP: on parcourt tous les chunks existants (sparse). Culling caméra possible en amélioration.
        for (int li = 0; li < Layers.Count; li++)
        {
            foreach (var ((cx, cy), chunk) in Layers[li].Chunks)
            {
                DrawChunk(chunk, cx, cy, tilesPerRow);
            }
        }
    }

    void DrawChunk(Chunk chunk, int cx, int cy, int tilesPerRow)
    {
        int cs = ChunkSize;
        for (int ly = 0; ly < cs; ly++)
        {
            for (int lx = 0; lx < cs; lx++)
            {
                int tileId = chunk.Data[ly][lx];
                if (tileId == 0) continue;

                int atlasIndex = tileId - 1; // 1-based
                int column = atlasIndex % tilesPerRow;
                int row = atlasIndex / tilesPerRow;

                Rectangle sourceRec = new Rectangle(
                    column * TileSize,
                    row * TileSize,
                    TileSize,
                    TileSize
                );

                // Position monde = origine Tilemap + (coord grille globale * taille tuile)
                int gridX = cx * cs + lx;
                int gridY = cy * cs + ly;
                Vector2 screenPos = new Vector2(
                    Position.X + (gridX * TileSize),
                    Position.Y + (gridY * TileSize)
                );

                Raylib.DrawTextureRec(Texture, sourceRec, screenPos, Color.White);
            }
        }
    }
}



#---- ReForgeEngine/World/ActionTrigger.cs
namespace ReForge.Engine.World;
using ReForge.Engine.Core;

[HiddenSelectableBehavior] 
public class ActionTrigger: Behavior
{
    public List<ActionCommand> OnEnterActions { get; set; } = new();
    public List<ActionCommand> OnExitActions { get; set; } = new();
    
    public override void Update(float deltaTime)
    {
        
    }

    public override Behavior Clone()
    {
        return new ActionTrigger
        {
            OnEnterActions = this.OnEnterActions,
            OnExitActions = this.OnExitActions
        };
    }

    public override void OnReceivedEvent(string eventName, object? data = null)
    {
        Entity? entity = data as Entity;
        
        if (eventName == "OnCollisionEnter")
        {
            foreach (var action in OnEnterActions)
            {
                Execute(action, entity);
            }
        }

        if (eventName == "OnCollisionExit")
        {
            foreach (var action in OnExitActions)
            {
                // On éxecute les actions
            }
        }
    }

    void Execute(ActionCommand command, Entity? entity = null)
    {
        List<Entity> targets = new();

        if (command.TargetSelf)
        {
            targets.Add(Owner);
        }
        else if (!string.IsNullOrEmpty(command.TargetTag))
        {
            var found = Engine.Instance.CurrentScene.Entities
                .Where(e => e.HasTag(command.TargetTag.Trim()));
            targets.AddRange(found);
        }
        else if (entity != null)
        {
            targets.Add(entity);
        }

        foreach (var target in targets)
        {
            switch (command.Verb)
            {
                case ActionVerb.Destroy:
                    Engine.Instance.CurrentScene.DestroyEntity(target);
                    break;
                case ActionVerb.Teleport:
                    target.Position = command.Destination;
                    break;
            }
        }
    }
}


#---- ReForgeEngine/World/Entity.cs
using System.Numerics;
using System.Text.Json.Serialization;
using Raylib_cs;
using ReForge.Engine.World.Behaviors;
using ReForge.Engine.World.Components;

namespace ReForge.Engine.World;

public class Entity
{
    // Fields
    private List<Behavior> _behaviors = new List<Behavior>();
    private List<string> _tags = new List<string>();

    // Properties
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = "Nouvel element";
    public int ZIndex { get; set; } = 0;

    [JsonIgnore]
    public Vector2 Position 
    {
        get => GetBehavior<TransformComponent>().Position;
        set => GetBehavior<TransformComponent>().Position = value;
    }

    [JsonIgnore]
    public string TexturePath
    {
        get => GetBehavior<SpriteComponent>()?.TexturePath ?? "";
        set => GetBehavior<SpriteComponent>()?.TexturePath = value;
    }

    [JsonIgnore]
    public Texture2D Texture
    {
        get => GetBehavior<SpriteComponent>()?.Texture ?? new Texture2D();
        set { if(GetBehavior<SpriteComponent>()?.Texture != null) GetBehavior<SpriteComponent>().Texture = value; }
    }

    public List<string> Tags
    {
        get => _tags;
        set => _tags = value;
    }

    public List<Behavior> Behaviors
    {
        get => _behaviors;
        set => _behaviors = value;
    }

    public TransformComponent Transform => GetBehavior<TransformComponent>();
    public SpriteComponent Sprite => GetBehavior<SpriteComponent>();

    // Constructors
    public Entity()
    {
        AddBehavior(new TransformComponent());
    }

    public Entity(Vector2 position, Texture2D texture, string name, string texturePath) : this()
    {
        AddBehavior(new SpriteComponent());
        Position = position;
        Texture = texture;
        TexturePath = texturePath;
        Name = name;
    }

    // Public Methods
    public virtual void Update(float deltaTime)
    {
        // Exécuter les behaviors selon leur ordre d'update
        foreach (Behavior behavior in _behaviors.OrderBy(b => b.UpdateOrder))
        {
            behavior.Update(deltaTime);
        }
    }

    public virtual void Draw()
    {
        var sprite = Sprite;
        if (sprite != null && sprite.Texture.Id != 0)
        {
            Raylib.DrawTextureV(Texture, Position, Color.White);
        }
    }

    // Behavior Management
    public void AddBehavior(Behavior behavior)
    {
        behavior.Owner = this;
        
        if (behavior is BoxCollider && GetBehavior<ActionTrigger>() == null)
        {
            var trigger = new ActionTrigger();
            trigger.Owner = this;
            AddBehavior(trigger);
        }

        // Empêcher les doublons pour les composants essentiels
        if (behavior is TransformComponent && this.GetBehavior<TransformComponent>() != null) 
        {
            // On met à jour la position si nécessaire ou on ignore simplement
            var existing = this.GetBehavior<TransformComponent>();
            existing.Position = ((TransformComponent)behavior).Position;
            return;
        }

        if (behavior is SpriteComponent && this.GetBehavior<SpriteComponent>() != null)
        {
            var existing = this.GetBehavior<SpriteComponent>();
            existing.TexturePath = ((SpriteComponent)behavior).TexturePath;
            existing.Texture = ((SpriteComponent)behavior).Texture;
            return;
        }
        
        _behaviors.Add(behavior);
        behavior.Initialize();
    }

    public void RemoveBehavior(Behavior behavior)
    {
        _behaviors.Remove(behavior);
    }

    public T? GetBehavior<T>() where T : Behavior
    {
        return _behaviors.OfType<T>().FirstOrDefault();
    }

    public void BroadcastEvent(string eventName, object data)
    {
        foreach (Behavior behavior in _behaviors)
        {
            behavior.OnReceivedEvent(eventName, data);
        }
    }

    // Tag Management
    public void AddTag(string tag) => _tags.Add(tag);
    public bool HasTag(string tag) => _tags.Contains(tag);
    public void RemoveTag(string tag) => _tags.Remove(tag);

    // Lifecycle
    public virtual Entity Clone()
    {
        var clone = new Entity(this.Position, this.Texture, this.Name, this.TexturePath);
        clone.Id = Guid.NewGuid(); // On s'assure d'avoir un nouvel ID
        clone.ZIndex = this.ZIndex;
        
        foreach (var tag in _tags) clone.AddTag(tag);

        foreach (var behavior in _behaviors)
        {
            var clonedBehavior = behavior.Clone();
            clone.AddBehavior(clonedBehavior);
        }
        
        return clone;
    }
}



#---- ReForgeEngine/Physics/CollisionSystem.cs
using System.Numerics;
using Raylib_cs;
using ReForge.Engine.World;
using ReForge.Engine.World.Behaviors;

namespace ReForge.Engine.Physics;

public static class CollisionSystem
{
    static HashSet<(int, int)> _activeCollisions = new HashSet<(int, int)>();
    
    public static void Update(List<Entity> entities)
    {
        var collidables = entities.Where(e => e.GetBehavior<BoxCollider>() != null).ToList();
        HashSet<(int, int)> currentFramePosition = new HashSet<(int, int)>();
        
        for (int i = 0; i < collidables.Count; i++)
        {
            var entA = collidables[i];
            var colA = entA.GetBehavior<BoxCollider>();
            if (colA == null) continue;

            for (int j = i + 1; j < collidables.Count; j++)
            {
                var entB = collidables[j];
                var colB = entB.GetBehavior<BoxCollider>();
                if (colB == null) continue;

                if (Raylib.CheckCollisionRecs(colA.Bounds, colB.Bounds))
                {
                    var pair = (entA.GetHashCode(), entB.GetHashCode());
                    currentFramePosition.Add(pair);

                    if (!_activeCollisions.Contains(pair))
                    {
                        /* ENTER */
                        colA.OnCollisionEnter?.Invoke(entB);
                        colB.OnCollisionEnter?.Invoke(entA);
                    }
                    else
                    {
                        /* STAY */
                        colA.OnCollisionStay?.Invoke(entB);
                        colB.OnCollisionStay?.Invoke(entA);
                    }
                    
                    /* PHYSIC COLLISION */
                    if (!colA.IsTrigger && !colB.IsTrigger)
                    {
                        Rectangle overlap = Raylib.GetCollisionRec(colA.Bounds, colB.Bounds);
                        
                        Vector2 newPos = entA.Position;
                        
                        if (overlap.Width < overlap.Height)
                        {
                            if(entA.Position.X < entB.Position.X) 
                                newPos.X -= overlap.Width;
                            else 
                                newPos.X += overlap.Width;
                        }
                        else
                        {
                            if(entA.Position.Y < entB.Position.Y) 
                                newPos.Y -= overlap.Height;
                            else 
                                newPos.Y += overlap.Height;
                        }
                        entA.Position = newPos;
                    }
                }
            }
        }
        
        /* EXIT */
        foreach (var pair in _activeCollisions)
        {
            if (!currentFramePosition.Contains(pair))
            {
                var entA = entities.FirstOrDefault(e => e.GetHashCode() == pair.Item1);
                var entB = entities.FirstOrDefault(e => e.GetHashCode() == pair.Item2);
                
                entA?.GetBehavior<BoxCollider>()?.OnCollisionExit?.Invoke(entB);
                entB?.GetBehavior<BoxCollider>()?.OnCollisionExit?.Invoke(entA);
            }
        }
        _activeCollisions = currentFramePosition;
    }
}



